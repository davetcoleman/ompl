/*********************************************************************
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2013, Rutgers the State University of New Jersey, New Brunswick
 *  Copyright (c) 2014, University of Colorado, Boulder
 *  All Rights Reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of Rutgers University nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************/

/* Author: Andrew Dobson, Dave Coleman */

#include <ompl/tools/bolt/PRMdb.h>
#include <ompl/geometric/planners/prm/ConnectionStrategy.h>
#include <ompl/base/goals/GoalSampleableRegion.h>
#include <ompl/tools/config/SelfConfig.h>
#include <ompl/util/Console.h>
#include <boost/lambda/bind.hpp>
#include <boost/graph/astar_search.hpp>
#include <boost/graph/incremental_components.hpp>
#include <boost/property_map/vector_property_map.hpp>
#include <ompl/base/spaces/RealVectorStateSpace.h>




// PRMdb methods ////////////////////////////////////////////////////////////////////////////////////////

ompl::geometric::PRMdb::PRMdb(const base::SpaceInformationPtr &si) :
    base::Planner(si, "PRMdb"),
    // Numeric variables
    //stretchFactor_(3.),
    // sparseDeltaFraction_(.25),
    // denseDeltaFraction_(.001),
    // maxFailures_(5000),
    // numPathInsertionFailures_(0),
    // nearSamplePoints_((2*si_->getStateDimension())),
    // Disjoint set accessors
    //disjointSets_(boost::get(boost::vertex_rank, g_),
    //boost::get(boost::vertex_predecessor, g_)),
    // addedSolution_(false),
    // consecutiveFailures_(0),
    // iterations_(0),

    // denseDelta_(0.),
{
    // specs_.recognizedGoal = base::GOAL_SAMPLEABLE_REGION;
    // specs_.approximateSolutions = false;
    // specs_.optimizingPaths = true;

    // psimp_.reset(new PathSimplifier(si_));

    // Planner::declareParam<double>("stretch_factor", this, &PRMdb::setStretchFactor, &PRMdb::getStretchFactor, "1.1:0.1:3.0");
    // Planner::declareParam<double>("sparse_delta_fraction", this, &PRMdb::setSparseDeltaFraction, &PRMdb::getSparseDeltaFraction, "0.0:0.01:1.0");
    // Planner::declareParam<double>("dense_delta_fraction", this, &PRMdb::setDenseDeltaFraction, &PRMdb::getDenseDeltaFraction, "0.0:0.0001:0.1");
    // Planner::declareParam<unsigned int>("max_failures", this, &PRMdb::setMaxFailures, &PRMdb::getMaxFailures, "100:10:3000");
}

void ompl::geometric::PRMdb::setup()
{
    Planner::setup();

    //double maxExt = si_->getMaximumExtent();
    //sparseDelta_ = sparseDeltaFraction_ * maxExt;
    //denseDelta_ = denseDeltaFraction_ * maxExt;

    //if (!sampler_)
    //sampler_ = si_->allocValidStateSampler();
}

void ompl::geometric::PRMdb::clear()
{
    Planner::clear();
    clearQuery();
    //resetFailures();
    //iterations_ = 0;
    freeMemory();
    if (nn_)
        nn_->clear();
}

// bool ompl::geometric::PRMdb::sameComponent(Vertex m1, Vertex m2)
// {
//     return boost::same_component(m1, m2, disjointSets_);
// }

// bool ompl::geometric::PRMdb::reachedFailureLimit() const
// {
//     return consecutiveFailures_ >= maxFailures_;
// }

// void ompl::geometric::PRMdb::printDebug(std::ostream &out) const
// {
//     out << "PRMdb Debug Output: " << std::endl;
//     out << "  Settings: " << std::endl;
//     out << "    Max Failures: " << getMaxFailures() << std::endl;
//     out << "    Dense Delta Fraction: " << getDenseDeltaFraction() << std::endl;
//     out << "    Sparse Delta Fraction: " << getSparseDeltaFraction() << std::endl;
//     out << "    Sparse Delta: " << sparseDelta_ << std::endl;
//     out << "    Stretch Factor: " << getStretchFactor() << std::endl;
//     out << "    Maximum Extent: " << si_->getMaximumExtent() << std::endl;
//     out << "  Status: " << std::endl;
//     out << "    Vertices Count: " << getNumVertices() << std::endl;
//     out << "    Edges Count:    " << getNumEdges() << std::endl;
//     out << "    Iterations: " << getIterations() << std::endl;
//     out << "    Consecutive Failures: " << consecutiveFailures_ << std::endl;
//     out << "    Number of guards: " << nn_->size() << std::endl << std::endl;
// }

// bool ompl::geometric::PRMdb::getGuardSpacingFactor(const double pathLength, int &numGuards, double &spacingFactor)
// {
//     static const double factorHigh = 1.9;
//     static const double factorLow = 1.1;
//     double minPathLength = sparseDelta_ * factorLow;

//     // Check if the path length is too short
//     if (pathLength < minPathLength )
//     {
//         OMPL_INFORM("Path length is too short to get a correct sparcing factor: length: %f, min: %f ", pathLength, minPathLength);
//         spacingFactor = factorLow;
//         return true; // still attempt
//     }

//     // Get initial guess using med value
//     double numGuardsFraction = pathLength / (sparseDelta_ * factorLow);
//     if (verbose_)
//     {
//         OMPL_INFORM("getGuardSpacingFactor: ");
//         OMPL_INFORM("  pathLength: %f", pathLength);
//         OMPL_INFORM("  sparseDelta: %f", sparseDelta_);
//         OMPL_INFORM("  min pathLength: %f", minPathLength);
//         OMPL_INFORM("  numGuardsFraction: %f", numGuardsFraction);
//     }

//     // Round down to nearest integer
//     numGuards = numGuardsFraction;

//     static std::size_t MAX_ATTEMPTS = 4;
//     for (std::size_t i = 0; i < MAX_ATTEMPTS; ++i)
//     {
//         if (verbose_)
//             OMPL_INFORM("  numGuards: %d", numGuards);

//         // Find the factor to achieve this number of guards
//         spacingFactor = pathLength / (sparseDelta_ * numGuards);
//         if (verbose_)
//             OMPL_INFORM("  new spacingFactor: %f", spacingFactor);

//         // Check if this factor is too low
//         if ( spacingFactor < factorLow )
//         {
//             if (verbose_)
//                 OMPL_INFORM("  spacing factor is too low ");
//             numGuards ++;
//             continue;
//         }
//         else if ( spacingFactor > factorHigh )
//         {
//             if (verbose_)
//                 OMPL_INFORM("  spacing factor is too high ");
//             numGuards --;
//             continue;
//         }
//         else
//             return true; // a good value
//     }

//     OMPL_ERROR("Unable to find correct spacing factor - perhaps this is a bug");
//     spacingFactor = factorLow;
//     return true; // still attempt
// }

 bool ompl::geometric::PRMdb::addPathToRoadmap(const base::PlannerTerminationCondition &ptc,
                                                 ompl::geometric::PathGeometric& solutionPath)
 {
//     // Check that the query vertex is initialized (used for internal nearest neighbor searches)
//     initializeQueryState();

//     // Error check
//     if (solutionPath.getStateCount() < 2)
//     {
//         OMPL_ERROR("Less than 2 states were passed to addPathToRoadmap in the solution path");
//         return false;
//     }

//     // Find spacing factor - 2.0 would be a perfect amount, but we leave room for rounding/interpolation errors and curves in path
//     int numGuards; // unused variable that indicates how many guards we will add
//     double spacingFactor;
//     if (!getGuardSpacingFactor( solutionPath.length(), numGuards, spacingFactor ))
//         return false;

//     OMPL_DEBUG("Expected number of necessary coverage guards is calculated to be %i from the original path state count %i",
//                numGuards, solutionPath.getStateCount());

//     unsigned int n = 0;
//     const int n1 = solutionPath.getStateCount() - 1;
//     for (int i = 0 ; i < n1 ; ++i)
//         n += si_->getStateSpace()->validSegmentCount(solutionPath.getState(i), solutionPath.getState(i + 1));

//     solutionPath.interpolate(n);

//     // Debug
//     if (verbose_)
//     {
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("Attempting to add %d states to roadmap", solutionPath.getStateCount());
//         OMPL_INFORM("-------------------------------------------------------");
//     }

//     // Try to add the start first, but don't force it
//     addStateToRoadmap(ptc, solutionPath.getState(0));

// #ifdef OMPL_BOLT_DEBUG
//     visualizeStateCallback(solutionPath.getState(solutionPath.getStateCount() - 1), 3, sparseDelta_);
// #endif

//     // Add solution states to SPARSdb one by one ---------------------------

//     // Track which nodes we've already tried to add
//     std::vector<std::size_t> addedStateIDs;
//     // Track which nodes we will attempt to use as connectivity states
//     std::vector<std::size_t> connectivityStateIDs;
//     //std::vector<base::State*> connectivityStates;

//     double distanceFromLastState = 0;

//     std::size_t lastStateID = 0; // track the id in the solutionPath of the last state

//     for (std::size_t i = 1; i < solutionPath.getStateCount(); ++i)  // skip 0 and last because those are start/goal and are already added
//     {
//         distanceFromLastState = si_->distance( solutionPath.getState(i), solutionPath.getState(lastStateID));

//         if (verbose_ && false)
//         {
//             OMPL_INFORM("Index %d at distance %f from last state ", i, distanceFromLastState);
//         }

//         if (distanceFromLastState >= sparseDelta_ * spacingFactor)
//         {
//             if (verbose_)
//             {
//                 OMPL_INFORM("Adding state %d of %d", i, solutionPath.getStateCount());
//             }

//             // Show the candidate state in Rviz for path insertion of GUARDS
// #ifdef OMPL_BOLT_DEBUG
//             visualizeStateCallback(solutionPath.getState(i), 1, sparseDelta_);
// #endif

//             // Add a single state to the roadmap
//             if (!addStateToRoadmap(ptc, solutionPath.getState(i)))
//             {
//                 if (verbose_)
//                 {
//                     OMPL_INFORM("Last state added to roadmap failed ");
//                 }
//             }

//             // Now figure out midpoint state between lastState and i
//             std::size_t midStateID = (i - lastStateID)/2 + lastStateID;
//             connectivityStateIDs.push_back(midStateID);

//             double distA = si_->distance( solutionPath.getState(lastStateID), solutionPath.getState(midStateID));
//             double distB = si_->distance( solutionPath.getState(i), solutionPath.getState(midStateID));
//             double diff = distA - distB;
//             if ((diff < std::numeric_limits<double>::epsilon()) && (-diff < std::numeric_limits<double>::epsilon()))
//                 if (verbose_)
//                     OMPL_WARN("DISTANCES ARE DIFFERENT ");

//             // Save this state as the new last state
//             lastStateID = i;
//             // Remember which nodes we've already added / attempted to add
//             addedStateIDs.push_back(midStateID);
//             addedStateIDs.push_back(i);

//         }
//         // Close up if it doesn't do it automatically
//         else if (i == solutionPath.getStateCount() - 1)
//         {
//             if (verbose_)
//                 OMPL_INFORM("Last state - do special midpoint");

//             // Now figure out midpoint state between lastState and i
//             std::size_t midStateID = (i - lastStateID)/2 + lastStateID;
//             connectivityStateIDs.push_back(midStateID);
//             addedStateIDs.push_back(midStateID);
//             if (verbose_)
//                 OMPL_INFORM("Mid state is %d", midStateID);
//         }
//     }

//     // Attempt to add the goal directly
//     addStateToRoadmap(ptc, solutionPath.getState(solutionPath.getStateCount() - 1));

//     if (verbose_)
//     {
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("Adding connectivity states ----------------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//     }

//     for (std::size_t i = 0; i < connectivityStateIDs.size(); ++i)
//     {
//         base::State* connectivityState = solutionPath.getState( connectivityStateIDs[i] );

//         if (verbose_)
//         {
//             OMPL_INFORM("Adding connectvity state ", i);
//         }

// #ifdef OMPL_BOLT_DEBUG
//         // Show the candidate state in Rviz for path insertion of BRIDGES (CONNECTIVITY)
//         visualizeStateCallback(connectivityState, 2, sparseDelta_);
//         sleep(0.5);
// #endif

//         // Add a single state to the roadmap
//         addStateToRoadmap(ptc, connectivityState);
//     }

//     // Add remaining states at random
//     if (verbose_)
//     {
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("Adding remaining states randomly ----------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//         OMPL_INFORM("-------------------------------------------------------");
//     }

//     // Create a vector of shuffled indexes
//     std::vector<std::size_t> shuffledIDs;
//     std::size_t usedIDTracker = 0;
//     for (std::size_t i = 1; i < solutionPath.getStateCount(); ++i)  // skip 0 because start already added
//     {
//         // Check if we've already used this id
//         if (i == addedStateIDs[usedIDTracker])
//         {
//             // skip this id
//             usedIDTracker ++;
//             continue;
//         }

//         shuffledIDs.push_back(i); // 1 2 3...
//     }

//     std::random_shuffle ( shuffledIDs.begin(), shuffledIDs.end() ); // using built-in random generator:

//     // Add each state randomly
//     for (std::size_t i = 0; i < shuffledIDs.size(); ++i)
//     {

// #ifdef OMPL_BOLT_DEBUG
//         visualizeStateCallback(solutionPath.getState(shuffledIDs[i]), 1, sparseDelta_);
// #endif

//         // Add a single state to the roadmap
//         addStateToRoadmap(ptc, solutionPath.getState(shuffledIDs[i]));
//     }

//     bool benchmarkLogging = true;
//     if (benchmarkLogging)
//     {
//         OMPL_DEBUG("ompl::geometric::SPARSdb: Benchmark logging enabled (slower)");

//         // Return the result of inserting into database, if applicable
//         return checkStartGoalConnection( solutionPath );
//     }

     return true;
 }

// bool ompl::geometric::PRMdb::checkStartGoalConnection(ompl::geometric::PathGeometric& solutionPath)
// {
//     // Make sure path has states
//     if (solutionPath.getStateCount() < 2)
//     {
//         OMPL_ERROR("Not enought states (< 2) in the solutionPath");
//         return false;
//     }

//     bool error = false;
//     CandidateSolution candidateSolution;
//     do
//     {
//         base::State* actualStart = solutionPath.getState(0);
//         base::State* actualGoal = solutionPath.getState(solutionPath.getStateCount() - 1);

//         /* The whole neighborhood set which has been most recently computed */
//         std::vector<Vertex> graphNeighborhood;
//         /* The visible neighborhood set which has been most recently computed */
//         std::vector<Vertex> visibleNeighborhood;

//         // Get start vertex
//         findGraphNeighbors(actualStart, graphNeighborhood, visibleNeighborhood);
//         if (!visibleNeighborhood.size())
//         {
//             OMPL_ERROR("No vertexes found near start");
//             error = true;
//             break;
//         }
//         Vertex closeStart = visibleNeighborhood[0];

//         // Get goal vertex
//         findGraphNeighbors(actualGoal, graphNeighborhood, visibleNeighborhood);
//         if (!visibleNeighborhood.size())
//         {
//             OMPL_ERROR("No vertexes found near goal");
//             error = true;
//             break;
//         }
//         Vertex closeGoal = visibleNeighborhood[0];

//         // Check if connected
//         if (false)
//             if (!sameComponent(closeStart, closeGoal))
//             {
//                 OMPL_ERROR("Start and goal are not connected!");
//                 error = true;
//                 break;
//             }

//         // Get new path from start to goal
//         std::vector<Vertex> vertexPath;
//         if (!constructSolution(closeStart, closeGoal, vertexPath))
//         {
//             OMPL_ERROR("Unable to find path from start to goal - perhaps because of new obstacles");
//             error = true;
//             break;
//         }

//         // Convert to PathGeometric
//         bool disableCollisionWarning = true; // this is just for benchmarking purposes
//         if (!convertVertexPathToStatePath(vertexPath, actualStart, actualGoal, candidateSolution, disableCollisionWarning))
//         {
//             OMPL_ERROR("Unable to convert to state path");
//             error = true;
//             break;
//         }
//     } while(false);

//     // Check distance of new path from old path
//     double originalLength = solutionPath.length();

//     OMPL_DEBUG("Results of attempting to make insertion in PRMdb ");
//     OMPL_DEBUG("-------------------------------------------------------");
//     OMPL_DEBUG("Original length:    %f", originalLength);

//     if (error)
//     {
//         OMPL_ERROR("UNABLE TO GET PATH");

//         // Record this for plotting
//         numPathInsertionFailures_++;
//     }
//     else
//     {
//         double newLength = candidateSolution.getGeometricPath().length();
//         double percentIncrease = 100 - originalLength / newLength * 100;
//         OMPL_DEBUG("New length:        %f", newLength);
//         OMPL_DEBUG("Percent increase:  %f %%", percentIncrease);
//     }

//     return !error; // return true if it inserted correctly
// }

// bool ompl::geometric::PRMdb::addStateToRoadmap(const base::PlannerTerminationCondition &ptc, base::State *newState)
// {
//     bool stateAdded = false;
//     // Check that the query vertex is initialized (used for internal nearest neighbor searches)
//     initializeQueryState();

//     // Deep copy
//     base::State *qNew = si_->cloneState(newState);
//     base::State *workState = si_->allocState();

//     /* The whole neighborhood set which has been most recently computed */
//     std::vector<Vertex> graphNeighborhood;
//     /* The visible neighborhood set which has been most recently computed */
//     std::vector<Vertex> visibleNeighborhood;

//     ++iterations_;

//     findGraphNeighbors(qNew, graphNeighborhood, visibleNeighborhood);

//     if (verbose_)
//     {
//         OMPL_INFORM(" graph neighborhood: %d | visible neighborhood: %d", graphNeighborhood.size(),
//                     visibleNeighborhood.size());

//         BOOST_FOREACH(Vertex v, visibleNeighborhood)
//         {
//             OMPL_INFORM("Visible neighbor is vertex %f with distance %f ",
//                         v, si_->distance( qNew, stateProperty_[v]));
//         }
//     }

//     if (verbose_)
//         OMPL_INFORM(" - checkAddCoverage() Are other nodes around it visible?");
//     // Coverage criterion
//     if (!checkAddCoverage(qNew, visibleNeighborhood)) // Always add a node if no other nodes around it are visible (GUARD)
//     {
//         if (verbose_)
//             OMPL_INFORM(" -- checkAddConnectivity() Does this node connect neighboring nodes that are not connected? ");
//         // Connectivity criterion
//         if (!checkAddConnectivity(qNew, visibleNeighborhood))
//         {
//             if (verbose_)
//                 OMPL_INFORM(" --- checkAddInterface() Does this node's neighbor's need it to better connect them? ");
//             if (!checkAddInterface(qNew, graphNeighborhood, visibleNeighborhood))
//             {
//                 if (verbose_)
//                     OMPL_INFORM(" ---- Ensure SPARS asymptotic optimality");
//                 if (visibleNeighborhood.size() > 0)
//                 {
//                     std::map<Vertex, base::State*> closeRepresentatives;
//                     if (verbose_)
//                         OMPL_INFORM(" ----- findCloseRepresentatives()");

//                     findCloseRepresentatives(workState, qNew, visibleNeighborhood[0], closeRepresentatives, ptc);
//                     if (verbose_)
//                         OMPL_INFORM("------ Found %d close representatives", closeRepresentatives.size());

//                     for (std::map<Vertex, base::State*>::iterator it = closeRepresentatives.begin(); it != closeRepresentatives.end(); ++it)
//                     {
//                         if (verbose_)
//                             OMPL_INFORM(" ------ Looping through close representatives");
//                         updatePairPoints(visibleNeighborhood[0], qNew, it->first, it->second);
//                         updatePairPoints(it->first, it->second, visibleNeighborhood[0], qNew);
//                     }
//                     if (verbose_)
//                         OMPL_INFORM(" ------ checkAddPath()");
//                     if (checkAddPath(visibleNeighborhood[0]))
//                     {
//                         if (verbose_)
//                         {
//                             OMPL_INFORM("nearest visible neighbor added ");
//                         }
//                     }

//                     for (std::map<Vertex, base::State*>::iterator it = closeRepresentatives.begin(); it != closeRepresentatives.end(); ++it)
//                     {
//                         if (verbose_)
//                             OMPL_INFORM(" ------- Looping through close representatives to add path");
//                         checkAddPath(it->first);
//                         si_->freeState(it->second);
//                     }
//                     if (verbose_)
//                         OMPL_INFORM("------ Done with inner most loop ");
//                 }
//             }
//             else //  added for interface
//             {
//                 stateAdded = true;
//             }
//         }
//         else // added for connectivity
//         {
//             stateAdded = true;
//         }
//     }
//     else // added for coverage
//     {
//         stateAdded = true;
//     }

//     if (!stateAdded)
//         ++consecutiveFailures_;

//     si_->freeState(workState);
//     si_->freeState(qNew);

//     return stateAdded;
// }

// bool ompl::geometric::PRMdb::checkAddCoverage(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood)
// {
//     if (visibleNeighborhood.size() > 0)
//         return false;
//     //No free paths means we add for coverage
//     if (verbose_)
//         OMPL_INFORM(" --- Adding node for COVERAGE ");
//     Vertex v = addGuard(si_->cloneState(qNew), COVERAGE);
//     if (verbose_)
//         OMPL_INFORM("       Added vertex %f", v);

//     return true;
// }

// bool ompl::geometric::PRMdb::checkAddConnectivity(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood)
// {
//     // Identify visibile nodes around our new state that are unconnected (in different connected components)
//     // and connect them

//     std::vector<Vertex> statesInDiffConnectedComponents; // links
//     if (visibleNeighborhood.size() > 1) // if less than 2 there is no way to find a pair of nodes in different connected components
//     {
//         //For each neighbor
//         for (std::size_t i = 0; i < visibleNeighborhood.size(); ++i)
//         {
//             //For each other neighbor
//             for (std::size_t j = i + 1; j < visibleNeighborhood.size(); ++j)
//             {
//                 //If they are in different components
//                 if (!sameComponent(visibleNeighborhood[i], visibleNeighborhood[j]))
//                 {
//                     statesInDiffConnectedComponents.push_back(visibleNeighborhood[i]);
//                     statesInDiffConnectedComponents.push_back(visibleNeighborhood[j]);
//                 }
//             }
//         }

//         // Were any diconnected states found?
//         if (statesInDiffConnectedComponents.size() > 0)
//         {
//             if (verbose_)
//                 OMPL_INFORM(" --- Adding node for CONNECTIVITY ");
//             //Add the node
//             Vertex newVertex = addGuard(si_->cloneState(qNew), CONNECTIVITY);

//             for (std::size_t i = 0; i < statesInDiffConnectedComponents.size() ; ++i)
//             {
//                 //If there's no edge between the two new states
//                 // DTC: this should actually never happen - we just created the new vertex so
//                 // why would it be connected to anything?
//                 if (!boost::edge(newVertex, statesInDiffConnectedComponents[i], g_).second)
//                 {
//                     //The components haven't been united by previous links
//                     if (!sameComponent(statesInDiffConnectedComponents[i], newVertex))
//                         connectGuards(newVertex, statesInDiffConnectedComponents[i]);
//                 }
//             }

//             return true;
//         }
//     }
//     return false;
// }

// bool ompl::geometric::PRMdb::checkAddInterface(const base::State *qNew, std::vector<Vertex> &graphNeighborhood, std::vector<Vertex> &visibleNeighborhood)
// {
//     //If we have at least 2 neighbors
//     if (visibleNeighborhood.size() > 1)
//     {
//         // If the two closest nodes are also visible
//         if (graphNeighborhood[0] == visibleNeighborhood[0] && graphNeighborhood[1] == visibleNeighborhood[1])
//         {
//             // If our two closest neighbors don't share an edge
//             if (!boost::edge(visibleNeighborhood[0], visibleNeighborhood[1], g_).second)
//             {
//                 //If they can be directly connected
//                 if (si_->checkMotion(stateProperty_[visibleNeighborhood[0]], stateProperty_[visibleNeighborhood[1]]))
//                 {
//                     //Connect them
//                     if (verbose_)
//                         OMPL_INFORM(" ---   INTERFACE: directly connected nodes ");
//                     connectGuards(visibleNeighborhood[0], visibleNeighborhood[1]);
//                     //And report that we added to the roadmap
//                     resetFailures();
//                     //Report success
//                     return true;
//                 }
//                 else
//                 {
//                     //Add the new node to the graph, to bridge the interface
//                     if (verbose_)
//                         OMPL_INFORM(" --- Adding node for INTERFACE  ");
//                     Vertex v = addGuard(si_->cloneState(qNew), INTERFACE);
//                     connectGuards(v, visibleNeighborhood[0]);
//                     connectGuards(v, visibleNeighborhood[1]);
//                     if (verbose_)
//                         OMPL_INFORM(" ---   INTERFACE: connected two neighbors through new interface node ");
//                     //Report success
//                     return true;
//                 }
//             }
//         }
//     }
//     return false;
// }

// bool ompl::geometric::PRMdb::checkAddPath( Vertex v )
// {
//     bool spannerPropertyWasViolated = false;

//     std::vector< Vertex > rs;
//     BOOST_FOREACH( Vertex r, boost::adjacent_vertices( v, g_ ) )
//         rs.push_back(r);

//     /* Candidate x vertices as described in the method, filled by function computeX(). */
//     std::vector<Vertex> Xs;

//     /* Candidate v" vertices as described in the method, filled by function computeVPP(). */
//     std::vector<Vertex> VPPs;

//     for (std::size_t i = 0; i < rs.size() && !spannerPropertyWasViolated; ++i)
//     {
//         Vertex r = rs[i];
//         computeVPP(v, r, VPPs);
//         BOOST_FOREACH (Vertex rp, VPPs)
//         {
//             //First, compute the longest path through the graph
//             computeX(v, r, rp, Xs);
//             double rm_dist = 0.0;
//             BOOST_FOREACH( Vertex rpp, Xs)
//             {
//                 double tmp_dist = (si_->distance( stateProperty_[r], stateProperty_[v] )
//                                    + si_->distance( stateProperty_[v], stateProperty_[rpp] ) )/2.0;
//                 if( tmp_dist > rm_dist )
//                     rm_dist = tmp_dist;
//             }

//             InterfaceData& d = getData( v, r, rp );

//             //Then, if the spanner property is violated
//             if (rm_dist > stretchFactor_ * d.last_distance_)
//             {
//                 spannerPropertyWasViolated = true; //Report that we added for the path
//                 if (si_->checkMotion(stateProperty_[r], stateProperty_[rp]))
//                     connectGuards(r, rp);
//                 else
//                 {
//                     PathGeometric *p = new PathGeometric( si_ );
//                     if (r < rp)
//                     {
//                         p->append(d.sigmaA_);
//                         p->append(d.pointA_);
//                         p->append(stateProperty_[v]);
//                         p->append(d.pointB_);
//                         p->append(d.sigmaB_);
//                     }
//                     else
//                     {
//                         p->append(d.sigmaB_);
//                         p->append(d.pointB_);
//                         p->append(stateProperty_[v]);
//                         p->append(d.pointA_);
//                         p->append(d.sigmaA_);
//                     }

//                     psimp_->reduceVertices(*p, 10);
//                     psimp_->shortcutPath(*p, 50);

//                     if (p->checkAndRepair(100).second)
//                     {
//                         Vertex prior = r;
//                         Vertex vnew;
//                         std::vector<base::State*>& states = p->getStates();

//                         BOOST_FOREACH (base::State *st, states)
//                         {
//                             // no need to clone st, since we will destroy p; we just copy the pointer
//                             if (verbose_)
//                                 OMPL_INFORM(" --- Adding node for QUALITY");
//                             vnew = addGuard(st , QUALITY);

//                             connectGuards(prior, vnew);
//                             prior = vnew;
//                         }
//                         // clear the states, so memory is not freed twice
//                         states.clear();
//                         connectGuards(prior, rp);
//                     }

//                     delete p;
//                 }
//             }
//         }
//     }

//     if (!spannerPropertyWasViolated)
//     {
//         if (verbose_)
//         {
//             OMPL_INFORM(" ------- Spanner property was NOT violated, SKIPPING");
//         }
//     }

//     return spannerPropertyWasViolated;
// }

// void ompl::geometric::PRMdb::resetFailures()
// {
//     consecutiveFailures_ = 0;
// }

// void ompl::geometric::PRMdb::findGraphNeighbors(base::State *st, std::vector<Vertex> &graphNeighborhood,
//                                                   std::vector<Vertex> &visibleNeighborhood)
// {
//     visibleNeighborhood.clear();
//     stateProperty_[ queryVertex_ ] = st;
//     nn_->nearestR( queryVertex_, sparseDelta_, graphNeighborhood);
//     if (verbose_ && false)
//         OMPL_INFORM("Finding nearest nodes in NN tree within radius %f", sparseDelta_);
//     stateProperty_[ queryVertex_ ] = NULL;

//     //Now that we got the neighbors from the NN, we must remove any we can't see
//     for (std::size_t i = 0; i < graphNeighborhood.size() ; ++i )
//         if (si_->checkMotion(st, stateProperty_[graphNeighborhood[i]]))
//             visibleNeighborhood.push_back(graphNeighborhood[i]);
// }


// void ompl::geometric::PRMdb::approachGraph( Vertex v )
// {
//     std::vector< Vertex > hold;
//     nn_->nearestR( v, sparseDelta_, hold );

//     std::vector< Vertex > neigh;
//     for (std::size_t i = 0; i < hold.size(); ++i)
//         if (si_->checkMotion( stateProperty_[v], stateProperty_[hold[i]]))
//             neigh.push_back( hold[i] );

//     BOOST_FOREACH (Vertex vp, neigh)
//         connectGuards(v, vp);
// }

// ompl::geometric::PRMdb::Vertex ompl::geometric::PRMdb::findGraphRepresentative(base::State *st)
// {
//     std::vector<Vertex> nbh;
//     stateProperty_[ queryVertex_ ] = st;
//     nn_->nearestR( queryVertex_, sparseDelta_, nbh);
//     stateProperty_[queryVertex_] = NULL;

//     if (verbose_)
//         OMPL_INFORM(" ------- findGraphRepresentative found %d nearest neighbors of distance %f",
//                     nbh.size(), sparseDelta_);

//     Vertex result = boost::graph_traits<Graph>::null_vertex();

//     for (std::size_t i = 0 ; i< nbh.size() ; ++i)
//     {
//         if (verbose_)
//             OMPL_INFORM(" -------- Checking motion of graph rep candidate %d", i);
//         if (si_->checkMotion(st, stateProperty_[nbh[i]]))
//         {
//             if (verbose_)
//                 OMPL_INFORM(" --------- VALID ");
//             result = nbh[i];
//             break;
//         }
//     }
//     return result;
// }

// void ompl::geometric::PRMdb::findCloseRepresentatives(base::State *workState, const base::State *qNew, const Vertex qRep,
//                                                         std::map<Vertex, base::State*> &closeRepresentatives,
//                                                         const base::PlannerTerminationCondition &ptc)
// {
//     // Properly clear the vector by also deleting previously sampled unused states
//     for (std::map<Vertex, base::State*>::iterator it = closeRepresentatives.begin(); it != closeRepresentatives.end(); ++it)
//         si_->freeState(it->second);
//     closeRepresentatives.clear();

//     //denseDelta_ = 0.25 * sparseDelta_;
//     nearSamplePoints_ /= 10; // HACK - this makes it look for the same number of samples as dimensions

//     if (verbose_)
//         OMPL_INFORM(" ----- nearSamplePoints: %f, denseDelta: %f", nearSamplePoints_, denseDelta_);

//     // Then, begin searching the space around new potential state qNew
//     for (unsigned int i = 0 ; i < nearSamplePoints_ && ptc == false ; ++i)
//     {
//         do
//         {
//             sampler_->sampleNear(workState, qNew, denseDelta_);

// #ifdef OMPL_BOLT_DEBUG
//                 visualizeStateCallback(workState, 3, sparseDelta_);
//                 sleep(0.1);
// #endif

//             if (verbose_)
//             {
//                 OMPL_INFORM(" ------ findCloseRepresentatives sampled state ");

//                 if (!si_->isValid(workState))
//                 {
//                     OMPL_INFORM(" ------ isValid ");
//                 }
//                 if (si_->distance(qNew, workState) > denseDelta_)
//                 {
//                     OMPL_INFORM(" ------ Distance too far ");
//                 }
//                 if (!si_->checkMotion(qNew, workState))
//                 {
//                     OMPL_INFORM(" ------ Motion invalid ");
//                 }
//             }

//         } while ((!si_->isValid(workState) || si_->distance(qNew, workState) > denseDelta_ || !si_->checkMotion(qNew, workState)) && ptc == false);

//         // if we were not successful at sampling a desirable state, we are out of time
//         if (ptc == true)
//         {
//             if (verbose_)
//                 OMPL_INFORM(" ------ We are out of time ");
//             break;
//         }

//         if (verbose_)
//             OMPL_INFORM(" ------ Find graph representative ");

//         // Compute who his graph neighbors are
//         Vertex representative = findGraphRepresentative(workState);

//         // Assuming this sample is actually seen by somebody (which he should be in all likelihood)
//         if (representative != boost::graph_traits<Graph>::null_vertex())
//         {

//             if (verbose_)
//                 OMPL_INFORM(" ------ Representative is not null ");

//             //If his representative is different than qNew
//             if (qRep != representative)
//             {
//                 if (verbose_)
//                     OMPL_INFORM(" ------ qRep != representative ");

//                 //And we haven't already tracked this representative
//                 if (closeRepresentatives.find(representative) == closeRepresentatives.end())
//                 {
//                     if (verbose_)
//                         OMPL_INFORM(" ------ Track the representative");
//                     //Track the representativen
//                     closeRepresentatives[representative] = si_->cloneState(workState);
//                 }
//             }
//             else
//             {
//                 if (verbose_)
//                     OMPL_INFORM(" ------ qRep == representative, no good ");
//             }
//         }
//         else
//         {
//             if (verbose_)
//                 OMPL_INFORM(" ------ Rep is null ");

//             //This guy can't be seen by anybody, so we should take this opportunity to add him
//             if (verbose_)
//                 OMPL_INFORM(" --- Adding node for COVERAGE");
//             addGuard(si_->cloneState(workState), COVERAGE);

//             if (verbose_)
//             {
//                 OMPL_INFORM(" ------ STOP EFFORS TO ADD A DENSE PATH");
//             }

//             //We should also stop our efforts to add a dense path
//             for (std::map<Vertex, base::State*>::iterator it = closeRepresentatives.begin(); it != closeRepresentatives.end(); ++it)
//                 si_->freeState(it->second);
//             closeRepresentatives.clear();
//             break;
//         }
//     } // for loop
// }

// void ompl::geometric::PRMdb::updatePairPoints(Vertex rep, const base::State *q, Vertex r, const base::State *s)
// {
//     //First of all, we need to compute all candidate r'
//     std::vector<Vertex> VPPs;
//     computeVPP(rep, r, VPPs);

//     //Then, for each pair Pv(r,r')
//     BOOST_FOREACH (Vertex rp, VPPs)
//         //Try updating the pair info
//         distanceCheck(rep, q, r, s, rp);
// }

// void ompl::geometric::PRMdb::computeVPP(Vertex v, Vertex vp, std::vector<Vertex> &VPPs)
// {
//     VPPs.clear();
//     BOOST_FOREACH( Vertex cvpp, boost::adjacent_vertices( v, g_ ) )
//         if( cvpp != vp )
//             if( !boost::edge( cvpp, vp, g_ ).second )
//                 VPPs.push_back( cvpp );
// }

// void ompl::geometric::PRMdb::computeX(Vertex v, Vertex vp, Vertex vpp, std::vector<Vertex> &Xs)
// {
//     Xs.clear();

//     BOOST_FOREACH (Vertex cx, boost::adjacent_vertices(vpp, g_))
//         if (boost::edge(cx, v, g_).second && !boost::edge(cx, vp, g_).second)
//         {
//             InterfaceData& d = getData( v, vpp, cx );
//             if ((vpp < cx && d.pointA_) || (cx < vpp && d.pointB_))
//                 Xs.push_back( cx );
//         }
//     Xs.push_back(vpp);
// }

// ompl::geometric::PRMdb::VertexPair ompl::geometric::PRMdb::index( Vertex vp, Vertex vpp )
// {
//     if( vp < vpp )
//         return VertexPair( vp, vpp );
//     else if( vpp < vp )
//         return VertexPair( vpp, vp );
//     else
//         throw Exception( name_, "Trying to get an index where the pairs are the same point!");
// }

// ompl::geometric::PRMdb::InterfaceData& ompl::geometric::PRMdb::getData( Vertex v, Vertex vp, Vertex vpp )
// {
//     return interfaceDataProperty_[v].interfaceHash[index( vp, vpp )];
// }

// void ompl::geometric::PRMdb::distanceCheck(Vertex rep, const base::State *q, Vertex r, const base::State *s, Vertex rp)
// {
//     //Get the info for the current representative-neighbors pair
//     InterfaceData& d = getData( rep, r, rp );

//     if (r < rp) // FIRST points represent r (the guy discovered through sampling)
//     {
//         if (d.pointA_ == NULL) // If the point we're considering replacing (P_v(r,.)) isn't there
//             //Then we know we're doing better, so add it
//             d.setFirst(q, s, si_);
//         else //Otherwise, he is there,
//         {
//             if (d.pointB_ == NULL) //But if the other guy doesn't exist, we can't compare.
//             {
//                 //Should probably keep the one that is further away from rep?  Not known what to do in this case.
//                 // TODO: is this not part of the algorithm?
//             }
//             else //We know both of these points exist, so we can checkb some distances
//                 if (si_->distance(q, d.pointB_) < si_->distance(d.pointA_, d.pointB_))
//                     //Distance with the new point is good, so set it.
//                     d.setFirst( q, s, si_ );
//         }
//     }
//     else // SECOND points represent r (the guy discovered through sampling)
//     {
//         if (d.pointB_ == NULL) //If the point we're considering replacing (P_V(.,r)) isn't there...
//             //Then we must be doing better, so add it
//             d.setSecond(q, s, si_);
//         else //Otherwise, he is there
//         {
//             if (d.pointA_ == NULL) //But if the other guy doesn't exist, we can't compare.
//             {
//                 //Should we be doing something cool here?
//             }
//             else
//                 if (si_->distance(q, d.pointA_) < si_->distance(d.pointB_, d.pointA_))
//                     //Distance with the new point is good, so set it
//                     d.setSecond(q, s, si_);
//         }
//     }

//     // Lastly, save what we have discovered
//     interfaceDataProperty_[rep].interfaceHash[index(r, rp)] = d;
// }

// void ompl::geometric::PRMdb::abandonLists(base::State *st)
// {
//     stateProperty_[ queryVertex_ ] = st;

//     std::vector< Vertex > hold;
//     nn_->nearestR( queryVertex_, sparseDelta_, hold );

//     stateProperty_[queryVertex_] = NULL;

//     //For each of the vertices
//     BOOST_FOREACH (Vertex v, hold)
//     {
//         BOOST_FOREACH (VertexPair r, interfaceDataProperty_[v].interfaceHash | boost::adaptors::map_keys)
//             interfaceDataProperty_[v].interfaceHash[r].clear(si_);
//     }
// }

// ompl::geometric::PRMdb::Vertex ompl::geometric::PRMdb::addGuard(base::State *state, GuardType type)
// {
//     Vertex m = boost::add_vertex(g_);
//     stateProperty_[m] = state;
//     typeProperty_[m] = type;

//     //assert(si_->isValid(state));
//     abandonLists(state);

//     disjointSets_.make_set(m);
//     nn_->add(m);
//     resetFailures();

//     if (verbose_)
//     {
//         OMPL_INFORM(" ---- addGuard() of type %f", type);
//     }
// #ifdef OMPL_BOLT_DEBUG
//     visualizeStateCallback(state, 4, sparseDelta_); // Candidate node has already (just) been added
//     sleep(0.1);
// #endif


//     return m;
// }

// void ompl::geometric::PRMdb::connectGuards(Vertex v1, Vertex v2)
// {
//     //OMPL_INFORM("connectGuards called ---------------------------------------------------------------- ");
//     assert(v1 <= getNumVertices());
//     assert(v2 <= getNumVertices());

//     if (verbose_)
//     {
//         OMPL_INFORM(" ------- connectGuards/addEdge: Connecting vertex %f to vertex %f", v1, v2);
//     }

//     // Create the new edge
//     Edge e = (boost::add_edge(v1, v2, g_)).first;

//     // Add associated properties to the edge
//     edgeWeightProperty_[e] = distanceFunction(v1, v2); // TODO: use this value with astar
//     edgeCollisionStateProperty_[e] = NOT_CHECKED;

//     // Add the edge to the incrementeal connected components datastructure
//     disjointSets_.union_set(v1, v2);

//     // Debug in Rviz
// #ifdef OMPL_BOLT_DEBUG
//     visualizeEdgeCallback(stateProperty_[v1], stateProperty_[v2]);
//     sleep(0.8);
// #endif

// }

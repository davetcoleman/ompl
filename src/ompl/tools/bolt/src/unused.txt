    bool checkAsymptoticOptimal(const DenseVertex& denseV, std::size_t coutIndent);
    bool checkAddPath(DenseVertex q, const std::vector<DenseVertex>& neigh, std::size_t coutIndent);
    void computeVPP(SparseVertex v, SparseVertex vp, std::vector<SparseVertex>& VPPs);
    void computeX(SparseVertex v, SparseVertex vp, SparseVertex vpp, std::vector<SparseVertex>& Xs);
    bool addPathToSpanner(const DensePath& densePath, SparseVertex vp, SparseVertex vpp);
    void connectSparsePoints(SparseVertex v, SparseVertex vp);

bool SparseDB::checkAsymptoticOptimal(const DenseVertex &denseV, std::size_t coutIndent)
{
    if (fourthCheckVerbose_)
        std::cout << std::string(coutIndent, ' ') << "checkAsymptoticOptimal()" << std::endl;

    // Storage for the interface neighborhood, populated by getInterfaceNeighborhood()
    std::vector<DenseVertex> interfaceNeighborhood;

    // Check to see if Vertex is on an interface
    getInterfaceNeighborhood(denseV, interfaceNeighborhood, coutIndent + 4);
    if (interfaceNeighborhood.size() > 0)
    {
        if (fourthCheckVerbose_)
            std::cout << std::string(coutIndent + 2, ' ') << "Candidate vertex supports an interface" << std::endl;

        // Check for addition for spanner prop
        if (checkAddPath(denseV, interfaceNeighborhood, coutIndent + 4))
            return true;
    }
    else
    {
        if (fourthCheckVerbose_)
            std::cout << std::string(coutIndent + 2, ' ') << "Candidate vertex does NOT support an interface (no "
                                                            "neighbors)" << std::endl;
    }

    // All of the tests have failed.  Report failure for the sample
    return false;
}

bool SparseDB::checkAddPath(DenseVertex q, const std::vector<DenseVertex> &neigh, std::size_t coutIndent)
{
    if (fourthCheckVerbose_)
        std::cout << std::string(coutIndent, ' ') << "checkAddPath() DenseVertex: " << q << std::endl;

    bool spannerPropertyViolated = false;

    // Get q's representative => v
    SparseVertex v = denseDB_->representativesProperty_[q];

    // Extract the representatives of neigh => n_rep
    std::set<SparseVertex> neighborReps;
    foreach (DenseVertex qp, neigh)
        neighborReps.insert(denseDB_->representativesProperty_[qp]);

    // Feedback
    if (neighborReps.empty())
        if (fourthCheckVerbose_)
            std::cout << std::string(coutIndent + 2, ' ') << "neighborReps is empty" << std::endl;

    std::vector<SparseVertex> Xs;
    // for each v' in neighborReps
    for (std::set<SparseVertex>::iterator it = neighborReps.begin();
         it != neighborReps.end() && !spannerPropertyViolated; ++it)
    {
        if (fourthCheckVerbose_)
            std::cout << std::string(coutIndent + 2, ' ') << "for neighborRep " << *it << std::endl;

        SparseVertex vp = *it;
        // Identify appropriate v" candidates => vpps
        std::vector<SparseVertex> VPPs;
        computeVPP(v, vp, VPPs);

        foreach (SparseVertex vpp, VPPs)
        {
            if (fourthCheckVerbose_)
                std::cout << std::string(coutIndent + 4, ' ') << "for VPPs " << vpp << std::endl;

            double s_max = 0;
            // Find the X nodes to test
            computeX(v, vp, vpp, Xs);

            // For each x in xs
            foreach (SparseVertex x, Xs)
            {
                if (fourthCheckVerbose_)
                    std::cout << std::string(coutIndent + 6, ' ') << "for Xs " << x << std::endl;

                // Compute/Retain MAXimum distance path thorugh S
                double dist = (si_->distance(getSparseStateConst(x), getSparseStateConst(v)) +
                               si_->distance(getSparseStateConst(v), getSparseStateConst(vp))) /
                              2.0;
                if (dist > s_max)
                    s_max = dist;
            }

            DensePath bestDPath;
            DenseVertex best_qpp = boost::graph_traits<DenseGraph>::null_vertex();
            double d_min = std::numeric_limits<double>::infinity();  // Insanely big number
            // For each vpp in vpps
            for (std::size_t j = 0; j < VPPs.size() && !spannerPropertyViolated; ++j)
            {
                if (fourthCheckVerbose_)
                    std::cout << std::string(coutIndent + 6, ' ') << "for VPPs " << j << std::endl;

                SparseVertex vpp = VPPs[j];
                // For each q", which are stored interface nodes on v for i(vpp,v)
                foreach (DenseVertex qpp, interfaceListsProperty_[v].interfaceHash[vpp])
                {
                    if (fourthCheckVerbose_)
                        std::cout << std::string(coutIndent + 8, ' ') << "for interfaceHsh " << qpp << std::endl;

                    // check that representatives are consistent
                    assert(denseDB_->representativesProperty_[qpp] == v);

                    // If they happen to be the one and same node
                    if (q == qpp)
                    {
                        bestDPath.push_front(getDenseState(q));
                        best_qpp = qpp;
                        d_min = 0;
                    }
                    else
                    {
                        // Compute/Retain MINimum distance path on D through q, q"
                        DensePath dPath;
                        denseDB_->computeDensePath(q, qpp, dPath);
                        if (dPath.size() > 0)
                        {
                            // compute path length
                            double length = 0.0;
                            DensePath::const_iterator jt = dPath.begin();
                            for (DensePath::const_iterator it = jt + 1; it != dPath.end(); ++it)
                            {
                                length += si_->distance(*jt, *it);
                                jt = it;
                            }

                            if (length < d_min)
                            {
                                d_min = length;
                                bestDPath.swap(dPath);
                                best_qpp = qpp;
                            }
                        }
                    }
                }

                // If the spanner property is violated for these paths
                if (s_max > stretchFactor_ * d_min)
                {
                    // Need to augment this path with the appropriate neighbor information
                    DenseVertex na = getInterfaceNeighbor(q, vp);
                    DenseVertex nb = getInterfaceNeighbor(best_qpp, vpp);

                    bestDPath.push_front(getDenseState(na));
                    bestDPath.push_back(getDenseState(nb));

                    // check consistency of representatives
                    assert(denseDB_->representativesProperty_[na] == vp &&
                           denseDB_->representativesProperty_[nb] == vpp);

                    // Add the dense path to the spanner
                    addPathToSpanner(bestDPath, vpp, vp);

                    // Report success
                    spannerPropertyViolated = true;
                }
            }
        }
    }
    return spannerPropertyViolated;
}

void SparseDB::computeVPP(SparseVertex v, SparseVertex vp, std::vector<SparseVertex> &VPPs)
{
    foreach (SparseVertex cvpp, boost::adjacent_vertices(v, g_))
        if (cvpp != vp)
            if (!boost::edge(cvpp, vp, g_).second)
                VPPs.push_back(cvpp);
}

void SparseDB::computeX(SparseVertex v, SparseVertex vp, SparseVertex vpp, std::vector<SparseVertex> &Xs)
{
    Xs.clear();
    foreach (SparseVertex cx, boost::adjacent_vertices(vpp, g_))
        if (boost::edge(cx, v, g_).second && !boost::edge(cx, vp, g_).second)
            if (interfaceListsProperty_[vpp].interfaceHash[cx].size() > 0)
                Xs.push_back(cx);
    Xs.push_back(vpp);
}

bool SparseDB::addPathToSpanner(const DensePath &densePath, SparseVertex vp, SparseVertex vpp)
{
    // First, check to see that the path has length
    if (densePath.size() <= 1)
    {
        // The path is 0 length, so simply link the representatives
        connectSparsePoints(vp, vpp);
    }
    else
    {
        // We will need to construct a PathGeometric to do this.
        smoothingGeomPath_.getStates().resize(densePath.size());
        std::copy(densePath.begin(), densePath.end(), smoothingGeomPath_.getStates().begin());

        // Attemp tto simplify the path
        psimp_->reduceVertices(smoothingGeomPath_, smoothingGeomPath_.getStateCount() * 2);

        // we are sure there are at least 2 points left on smoothingGeomPath_
        std::vector<SparseVertex> addedNodes;
        addedNodes.reserve(smoothingGeomPath_.getStateCount());
        for (std::size_t i = 0; i < smoothingGeomPath_.getStateCount(); ++i)
        {
            // Add each guard
            OMPL_ERROR("addVertex with state %u", smoothingGeomPath_.getState(i));
            exit(-1);
            // SparseVertex ng = addVertex(si_->cloneState(smoothingGeomPath_.getState(i)), QUALITY);
            // addedNodes.push_back(ng);
        }
        // Link them up
        for (std::size_t i = 1; i < addedNodes.size(); ++i)
        {
            connectSparsePoints(addedNodes[i - 1], addedNodes[i]);
        }
        // Don't forget to link them to their representatives
        connectSparsePoints(addedNodes[0], vp);
        connectSparsePoints(addedNodes[addedNodes.size() - 1], vpp);
    }
    smoothingGeomPath_.getStates().clear();
    return true;
}

void SparseDB::connectSparsePoints(SparseVertex v, SparseVertex vp)
{
    OMPL_ERROR("connectSparsePoints");
    exit(-1);
    // const base::Cost weight(costHeuristic(v, vp));
    // const SpannerGraph::edge_property_type properties(weight);
    // boost::mutex::scoped_lock _(graphMutex_);
    // boost::add_edge(v, vp, properties, g_);
    // sparseDJSets_.union_set(v, vp);
}

DenseVertex SparseDB::getInterfaceNeighbor(DenseVertex q, SparseVertex rep)
{
    foreach (DenseVertex vp, boost::adjacent_vertices(q, g_))
        if (denseDB_->representativesProperty_[vp] == rep)
            if (distanceFunction(q, vp) <= denseDelta_)
                return vp;
    throw Exception("SparseDB", "Vertex has no interface neighbor with given representative");
}

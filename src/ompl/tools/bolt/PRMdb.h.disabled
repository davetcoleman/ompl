/*********************************************************************
* Software License Agreement (BSD License)
*
*  Copyright (c) 2013, Rutgers the State University of New Jersey, New Brunswick
*  All Rights Reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Rutgers University nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

/* Author: Andrew Dobson, Dave Coleman */

#ifndef OMPL_TOOLS_BOLT_PRM_DB_
#define OMPL_TOOLS_BOLT_PRM_DB_

#include <ompl/geometric/planners/PlannerIncludes.h>
#include <ompl/datastructures/NearestNeighbors.h>
#include <ompl/geometric/PathSimplifier.h>
#include <ompl/util/Time.h>

#include <iostream>
#include <fstream>
#include <utility>
#include <vector>
#include <map>

namespace ompl
{

    namespace geometric
    {

        /**
           @anchor gPRMdb
           @par Short description
           PRMdb is a variant of the PRM algorithm which removes the
           dependency on having the dense graph, D.  It works through similar
           mechanics, but uses a different approach to identifying interfaces
           and computing shortest paths through said interfaces.

           This version has been modified for use with Bolt

           @par External documentation
           A. Dobson, K. Bekris,
           Improving Prme Roadmap Spanners,
           <em>IEEE International Conference on Robotics and Automation (ICRA)</em> May 2013.
           <a href="http://www.cs.rutgers.edu/~kb572/pubs/prm2.pdf">[PDF]</a>
        */

        /** \brief <b> Sparse Roadmap Spanner Version 2.0 </b> */
        class PRMdb : public base::Planner
        {
        public:

        //     /** \brief Sets the stretch factor */
        //     void setStretchFactor(double t)
        //     {
        //         stretchFactor_ = t;
        //     }

        //     /** \brief Sets vertex visibility range as a fraction of max. extent. */
        //     void setSparseDeltaFraction( double D )
        //     {
        //         sparseDeltaFraction_ = D;
        //         if (sparseDelta_ > 0.0) // setup was previously called
        //             sparseDelta_ = D * si_->getMaximumExtent();
        //     }

        //     /** \brief Sets interface support tolerance as a fraction of max. extent. */
        //     void setDenseDeltaFraction( double d )
        //     {
        //         denseDeltaFraction_ = d;
        //         if (denseDelta_ > 0.0) // setup was previously called
        //             denseDelta_ = d * si_->getMaximumExtent();
        //     }

        //     /** \brief Sets the maximum failures until termination */
        //     void setMaxFailures( unsigned int m )
        //     {
        //         maxFailures_ = m;
        //     }

        //     /** \brief Retrieve the maximum consecutive failure limit. */
        //     unsigned int getMaxFailures( ) const
        //     {
        //         return maxFailures_;
        //     }

        //     /** \brief Retrieve the dense graph interface support delta. */
        //     double getDenseDeltaFraction( ) const
        //     {
        //         return denseDeltaFraction_;
        //     }

        //     /** \brief Retrieve the sparse graph visibility range delta. */
        //     double getSparseDeltaFraction( ) const
        //     {
        //         return sparseDeltaFraction_;
        //     }

        //     /** \brief Retrieve the spanner's set stretch factor. */
        //     double getStretchFactor( ) const
        //     {
        //         return stretchFactor_;
        //     }

        //     bool getGuardSpacingFactor(const double pathLength, double &numGuards, double &spacingFactor);

        //     /**
        //      * \brief Calculate the distance that should be used in inserting nodes into the db
        //      * \param path length - from the trajectory
        //      * \param num guards - the output result
        //      * \param spacing factor - what fraction of the sparsedelta should be used in placing guards
        //      * \return
        //      */
        //     bool getGuardSpacingFactor(const double pathLength, int &numGuards, double &spacingFactor);

            bool addPathToRoadmap(const base::PlannerTerminationCondition &ptc,
                                  ompl::geometric::PathGeometric& solutionPath);

        //     bool checkStartGoalConnection(ompl::geometric::PathGeometric& solutionPath);

        //     bool addStateToRoadmap(const base::PlannerTerminationCondition &ptc, base::State *newState);


        //     /** \brief Set a different nearest neighbors datastructure */
        //     template<template<typename T> class NN>
        //     void setNearestNeighbors()
        //     {
        //         nn_.reset(new NN< Vertex >());
        //         if (isSetup())
        //             setup();
        //     }


            virtual void setup();


            /** \brief Get the number of disjoint sets in the sparse roadmap. */
            unsigned int getNumConnectedComponents() const
            {
              return 0; // TODO(davetcoleman):

                // // Make sure graph is populated
                // if (!getNumVertices())
                //     return 0;

                // std::vector<int> components(boost::num_vertices(g_));

                // // it always overcounts by 1, i think because it is missing vertex 0 which is the new state insertion component
                // return boost::connected_components(g_, &components[0]) - 1;
            }

        //     /** \brief Get the number of times a path was inserted into the database and it failed to have connectivity */
        //     unsigned int getNumPathInsertionFailed() const
        //     {
        //         return numPathInsertionFailures_;
        //     }

        //     /** \brief description */
        //     unsigned int getNumConsecutiveFailures() const
        //     {
        //         return consecutiveFailures_;
        //     }

        //     /** \brief Get the number of iterations the algorithm performed */
        //     long unsigned int getIterations() const
        //     {
        //         return iterations_;
        //     }

        //     /** \brief Returns whether we have reached the iteration failures limit, maxFailures_ */
        //     bool reachedFailureLimit () const;

        //     /** \brief Print debug information about planner */
        //     void printDebug(std::ostream &out = std::cout) const;


        //     /** \brief Checks to see if the sample needs to be added to ensure coverage of the space */
        //     bool checkAddCoverage(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood);

        //     /** \brief Checks to see if the sample needs to be added to ensure connectivity */
        //     bool checkAddConnectivity(const base::State *qNew, std::vector<Vertex> &visibleNeighborhood);

        //     /** \brief Checks to see if the current sample reveals the existence of an interface, and if so, tries to bridge it. */
        //     bool checkAddInterface(const base::State *qNew, std::vector<Vertex> &graphNeighborhood,
        //                            std::vector<Vertex> &visibleNeighborhood);

        //     /** \brief Checks vertex v for short paths through its region and adds when appropriate. */
        //     bool checkAddPath( Vertex v );

        //     /** \brief A reset function for resetting the failures count */
        //     void resetFailures();

        //     /** \brief Finds visible nodes in the graph near state */
        //     void findGraphNeighbors(base::State *state, std::vector<Vertex> &graphNeighborhood,
        //                             std::vector<Vertex> &visibleNeighborhood);

        //     /** \brief Approaches the graph from a given vertex */
        //     void approachGraph( Vertex v );

        //     /** \brief Finds the representative of the input state, st  */
        //     Vertex findGraphRepresentative(base::State *st);

        //     /** \brief Finds representatives of samples near qNew_ which are not his representative */
        //     void findCloseRepresentatives(base::State *workState, const base::State *qNew, Vertex qRep,
        //                                   std::map<Vertex, base::State*> &closeRepresentatives,
        //                                   const base::PlannerTerminationCondition &ptc);

        //     /** \brief High-level method which updates pair point information for repV_ with neighbor r */
        //     void updatePairPoints(Vertex rep, const base::State *q, Vertex r, const base::State *s);

        //     /** \brief Computes all nodes which qualify as a candidate v" for v and vp */
        //     void computeVPP(Vertex v, Vertex vp, std::vector<Vertex> &VPPs);

        //     /** \brief Computes all nodes which qualify as a candidate x for v, v', and v" */
        //     void computeX(Vertex v, Vertex vp, Vertex vpp, std::vector<Vertex> &Xs);

        //     /** \brief Rectifies indexing order for accessing the vertex data */
        //     VertexPair index( Vertex vp, Vertex vpp );

        //     /** \brief Retrieves the Vertex data associated with v,vp,vpp */
        //     InterfaceData& getData( Vertex v, Vertex vp, Vertex vpp );

        //     /** \brief Performs distance checking for the candidate new state, q against the current information */
        //     void distanceCheck(Vertex rep, const base::State *q, Vertex r, const base::State *s, Vertex rp);

        //     /** \brief When a new guard is added at state st, finds all guards who must abandon their interface information and deletes that information */
        //     void abandonLists(base::State *st);

        //     /** \brief Construct a guard for a given state (\e state) and store it in the nearest neighbors data structure */
        //     Vertex addGuard(base::State *state, GuardType type);

        //     /** \brief Connect two guards in the roadmap */
        //     void connectGuards( Vertex v1, Vertex v2 );

        //     /** Thread that checks for solution */
        //     void checkForSolution(const base::PlannerTerminationCondition &ptc, base::PathPtr &solution);


        //     /** \brief Check if two milestones (\e m1 and \e m2) are part of the same connected component. This is not a const function since we use incremental connected components from boost */
        //     bool sameComponent(Vertex m1, Vertex m2);

        //     /** \brief Sampler user for generating valid samples in the state space */
        //     base::ValidStateSamplerPtr                                          sampler_;

        //     /** \brief Stretch Factor as per graph spanner literature (multiplicative bound on path quality) */
        //     double                                                              stretchFactor_;

        //     /** \brief Maximum visibility range for nodes in the graph as a fraction of maximum extent. */
        //     double                                                              sparseDeltaFraction_;

        //     /** \brief Maximum range for allowing two samples to support an interface as a fraction of maximum extent. */
        //     double                                                              denseDeltaFraction_;

        //     /** \brief The number of consecutive failures to add to the graph before termination */
        //     unsigned int                                                        maxFailures_;

        //     /** \brief Track how many solutions fail to have connectivity at end */
        //     unsigned int                                                        numPathInsertionFailures_;

        //     /** \brief Number of sample points to use when trying to detect interfaces. */
        //     unsigned int                                                        nearSamplePoints_;

        //     /** \brief A path simplifier used to simplify dense paths added to the graph */
        //     PathSimplifierPtr                                                   psimp_;

        //     /** \brief Access to the interface pair information for the vertices */
        //     boost::property_map<Graph, vertex_interface_data_t>::type           interfaceDataProperty_;

        //     /** \brief Data structure that maintains the connected components */
        //     boost::disjoint_sets<
        //         boost::property_map<Graph, boost::vertex_rank_t>::type,
        //         boost::property_map<Graph, boost::vertex_predecessor_t>::type >
        //                                                                         disjointSets_;
        //     /** \brief Random number generator */
        //     RNG                                                                 rng_;

        //     /** \brief A flag indicating that a solution has been added during solve() */
        //     bool                                                                addedSolution_;

        //     /** \brief A counter for the number of consecutive failed iterations of the algorithm */
        //     unsigned int                                                        consecutiveFailures_;

        //     /** \brief A counter for the number of iterations of the algorithm */
        //     long unsigned int                                                   iterations_;

        //     /** \brief Maximum range for allowing two samples to support an interface */
        //     double                                                              denseDelta_;


      };

    }
}

#endif
